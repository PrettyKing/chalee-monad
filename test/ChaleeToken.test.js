const { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\ndescribe(\"ChaleeToken\", function () {\n  let chaleeToken;\n  let owner;\n  let addr1;\n  let addr2;\n  let addrs;\n\n  beforeEach(async function () {\n    // Get signers\n    [owner, addr1, addr2, ...addrs] = await ethers.getSigners();\n\n    // Deploy contract\n    const ChaleeToken = await ethers.getContractFactory(\"ChaleeToken\");\n    chaleeToken = await ChaleeToken.deploy();\n    await chaleeToken.deployed();\n  });\n\n  describe(\"Deployment\", function () {\n    it(\"Should set the right owner\", async function () {\n      expect(await chaleeToken.owner()).to.equal(owner.address);\n    });\n\n    it(\"Should assign initial supply to owner\", async function () {\n      const ownerBalance = await chaleeToken.balanceOf(owner.address);\n      expect(ownerBalance).to.equal(ethers.utils.parseEther(\"100000\"));\n    });\n\n    it(\"Should set correct token details\", async function () {\n      expect(await chaleeToken.name()).to.equal(\"Chalee Token\");\n      expect(await chaleeToken.symbol()).to.equal(\"CHAL\");\n      expect(await chaleeToken.decimals()).to.equal(18);\n    });\n\n    it(\"Should have correct max supply\", async function () {\n      const maxSupply = await chaleeToken.MAX_SUPPLY();\n      expect(maxSupply).to.equal(ethers.utils.parseEther(\"1000000\"));\n    });\n  });\n\n  describe(\"Minting\", function () {\n    it(\"Should allow owner to mint tokens\", async function () {\n      const mintAmount = ethers.utils.parseEther(\"1000\");\n      \n      await expect(chaleeToken.mint(addr1.address, mintAmount))\n        .to.emit(chaleeToken, \"TokensMinted\")\n        .withArgs(addr1.address, mintAmount);\n\n      expect(await chaleeToken.balanceOf(addr1.address)).to.equal(mintAmount);\n    });\n\n    it(\"Should not allow non-owner to mint\", async function () {\n      const mintAmount = ethers.utils.parseEther(\"1000\");\n      \n      await expect(\n        chaleeToken.connect(addr1).mint(addr2.address, mintAmount)\n      ).to.be.revertedWith(\"Ownable: caller is not the owner\");\n    });\n\n    it(\"Should not allow minting beyond max supply\", async function () {\n      const maxSupply = await chaleeToken.MAX_SUPPLY();\n      const currentSupply = await chaleeToken.totalMinted();\n      const remainingSupply = maxSupply.sub(currentSupply);\n      const excessAmount = remainingSupply.add(1);\n      \n      await expect(\n        chaleeToken.mint(addr1.address, excessAmount)\n      ).to.be.revertedWith(\"Exceeds max supply\");\n    });\n\n    it(\"Should not allow minting to zero address\", async function () {\n      const mintAmount = ethers.utils.parseEther(\"1000\");\n      \n      await expect(\n        chaleeToken.mint(ethers.constants.AddressZero, mintAmount)\n      ).to.be.revertedWith(\"Cannot mint to zero address\");\n    });\n  });\n\n  describe(\"Whitelist Minting\", function () {\n    beforeEach(async function () {\n      // Add addr1 to whitelist\n      await chaleeToken.updateWhitelist(addr1.address, true);\n    });\n\n    it(\"Should allow whitelisted users to mint\", async function () {\n      const mintAmount = ethers.utils.parseEther(\"500\");\n      \n      await expect(chaleeToken.connect(addr1).whitelistMint(mintAmount))\n        .to.emit(chaleeToken, \"TokensMinted\")\n        .withArgs(addr1.address, mintAmount);\n\n      expect(await chaleeToken.balanceOf(addr1.address)).to.equal(mintAmount);\n    });\n\n    it(\"Should not allow non-whitelisted users to mint\", async function () {\n      const mintAmount = ethers.utils.parseEther(\"500\");\n      \n      await expect(\n        chaleeToken.connect(addr2).whitelistMint(mintAmount)\n      ).to.be.revertedWith(\"Not whitelisted\");\n    });\n\n    it(\"Should enforce per-transaction limit\", async function () {\n      const excessAmount = ethers.utils.parseEther(\"1001\");\n      \n      await expect(\n        chaleeToken.connect(addr1).whitelistMint(excessAmount)\n      ).to.be.revertedWith(\"Amount exceeds limit\");\n    });\n\n    it(\"Should enforce personal total limit\", async function () {\n      const mintAmount = ethers.utils.parseEther(\"1000\");\n      \n      // Mint 5 times (5000 tokens total)\n      for (let i = 0; i < 5; i++) {\n        await chaleeToken.connect(addr1).whitelistMint(mintAmount);\n      }\n      \n      // Try to mint one more time\n      await expect(\n        chaleeToken.connect(addr1).whitelistMint(ethers.utils.parseEther(\"1\"))\n      ).to.be.revertedWith(\"Exceeds personal limit\");\n    });\n  });\n\n  describe(\"Whitelist Management\", function () {\n    it(\"Should allow owner to update whitelist\", async function () {\n      await expect(chaleeToken.updateWhitelist(addr1.address, true))\n        .to.emit(chaleeToken, \"WhitelistUpdated\")\n        .withArgs(addr1.address, true);\n\n      expect(await chaleeToken.whitelist(addr1.address)).to.be.true;\n    });\n\n    it(\"Should allow batch whitelist updates\", async function () {\n      const addresses = [addr1.address, addr2.address];\n      \n      await chaleeToken.batchUpdateWhitelist(addresses, true);\n      \n      expect(await chaleeToken.whitelist(addr1.address)).to.be.true;\n      expect(await chaleeToken.whitelist(addr2.address)).to.be.true;\n    });\n\n    it(\"Should not allow non-owner to update whitelist\", async function () {\n      await expect(\n        chaleeToken.connect(addr1).updateWhitelist(addr2.address, true)\n      ).to.be.revertedWith(\"Ownable: caller is not the owner\");\n    });\n  });\n\n  describe(\"Pause Functionality\", function () {\n    it(\"Should allow owner to pause and unpause\", async function () {\n      // Pause\n      await chaleeToken.pause();\n      expect(await chaleeToken.paused()).to.be.true;\n      \n      // Unpause\n      await chaleeToken.unpause();\n      expect(await chaleeToken.paused()).to.be.false;\n    });\n\n    it(\"Should prevent minting when paused\", async function () {\n      await chaleeToken.pause();\n      \n      const mintAmount = ethers.utils.parseEther(\"1000\");\n      await expect(\n        chaleeToken.mint(addr1.address, mintAmount)\n      ).to.be.revertedWith(\"Pausable: paused\");\n    });\n\n    it(\"Should prevent transfers when paused\", async function () {\n      const transferAmount = ethers.utils.parseEther(\"1000\");\n      \n      // Pause the contract\n      await chaleeToken.pause();\n      \n      await expect(\n        chaleeToken.transfer(addr1.address, transferAmount)\n      ).to.be.revertedWith(\"Pausable: paused\");\n    });\n\n    it(\"Should not allow non-owner to pause\", async function () {\n      await expect(\n        chaleeToken.connect(addr1).pause()\n      ).to.be.revertedWith(\"Ownable: caller is not the owner\");\n    });\n  });\n\n  describe(\"Utility Functions\", function () {\n    it(\"Should return correct remaining supply\", async function () {\n      const maxSupply = await chaleeToken.MAX_SUPPLY();\n      const totalMinted = await chaleeToken.totalMinted();\n      const remainingSupply = await chaleeToken.remainingSupply();\n      \n      expect(remainingSupply).to.equal(maxSupply.sub(totalMinted));\n    });\n\n    it(\"Should track minted amounts correctly\", async function () {\n      const mintAmount = ethers.utils.parseEther(\"1000\");\n      \n      await chaleeToken.updateWhitelist(addr1.address, true);\n      await chaleeToken.connect(addr1).whitelistMint(mintAmount);\n      \n      expect(await chaleeToken.mintedAmount(addr1.address)).to.equal(mintAmount);\n    });\n  });\n\n  describe(\"Transfer Functionality\", function () {\n    it(\"Should allow normal transfers when not paused\", async function () {\n      const transferAmount = ethers.utils.parseEther(\"1000\");\n      \n      await expect(\n        chaleeToken.transfer(addr1.address, transferAmount)\n      ).to.emit(chaleeToken, \"Transfer\")\n        .withArgs(owner.address, addr1.address, transferAmount);\n\n      expect(await chaleeToken.balanceOf(addr1.address)).to.equal(transferAmount);\n    });\n\n    it(\"Should allow transferFrom when approved\", async function () {\n      const transferAmount = ethers.utils.parseEther(\"1000\");\n      \n      // Approve addr1 to spend owner's tokens\n      await chaleeToken.approve(addr1.address, transferAmount);\n      \n      // Transfer from owner to addr2 via addr1\n      await expect(\n        chaleeToken.connect(addr1).transferFrom(owner.address, addr2.address, transferAmount)\n      ).to.emit(chaleeToken, \"Transfer\")\n        .withArgs(owner.address, addr2.address, transferAmount);\n\n      expect(await chaleeToken.balanceOf(addr2.address)).to.equal(transferAmount);\n    });\n  });\n});