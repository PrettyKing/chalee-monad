// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\n/**\n * @title ChaleeToken\n * @dev A simple ERC20 token for demo purposes on Monad Testnet\n */\ncontract ChaleeToken is ERC20, Ownable, Pausable {\n    uint256 public constant MAX_SUPPLY = 1000000 * 10**18; // 1 million tokens\n    uint256 public totalMinted;\n    \n    mapping(address => bool) public whitelist;\n    mapping(address => uint256) public mintedAmount;\n    \n    event TokensMinted(address indexed to, uint256 amount);\n    event WhitelistUpdated(address indexed account, bool status);\n    \n    constructor() ERC20(\"Chalee Token\", \"CHAL\") {\n        _mint(msg.sender, 100000 * 10**18); // Initial mint 100k tokens to deployer\n        totalMinted = 100000 * 10**18;\n    }\n    \n    /**\n     * @dev Mint tokens to specified address (only owner)\n     */\n    function mint(address to, uint256 amount) external onlyOwner whenNotPaused {\n        require(to != address(0), \"Cannot mint to zero address\");\n        require(totalMinted + amount <= MAX_SUPPLY, \"Exceeds max supply\");\n        \n        _mint(to, amount);\n        totalMinted += amount;\n        \n        emit TokensMinted(to, amount);\n    }\n    \n    /**\n     * @dev Allow whitelisted addresses to mint limited amounts\n     */\n    function whitelistMint(uint256 amount) external whenNotPaused {\n        require(whitelist[msg.sender], \"Not whitelisted\");\n        require(amount <= 1000 * 10**18, \"Amount exceeds limit\");\n        require(mintedAmount[msg.sender] + amount <= 5000 * 10**18, \"Exceeds personal limit\");\n        require(totalMinted + amount <= MAX_SUPPLY, \"Exceeds max supply\");\n        \n        _mint(msg.sender, amount);\n        totalMinted += amount;\n        mintedAmount[msg.sender] += amount;\n        \n        emit TokensMinted(msg.sender, amount);\n    }\n    \n    /**\n     * @dev Update whitelist status for an address\n     */\n    function updateWhitelist(address account, bool status) external onlyOwner {\n        whitelist[account] = status;\n        emit WhitelistUpdated(account, status);\n    }\n    \n    /**\n     * @dev Batch update whitelist\n     */\n    function batchUpdateWhitelist(address[] calldata accounts, bool status) external onlyOwner {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            whitelist[accounts[i]] = status;\n            emit WhitelistUpdated(accounts[i], status);\n        }\n    }\n    \n    /**\n     * @dev Pause contract functionality\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n    \n    /**\n     * @dev Unpause contract functionality\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n    \n    /**\n     * @dev Get remaining mintable supply\n     */\n    function remainingSupply() external view returns (uint256) {\n        return MAX_SUPPLY - totalMinted;\n    }\n    \n    /**\n     * @dev Override transfer to respect pause state\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override whenNotPaused {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}